<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WhatsApp WebRTC Bridge</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        background-color: #f5f5f5;
      }

      h1 {
        text-align: center;
        margin-top: 50px;
        font-size: 50px;
      }

      p.description {
        text-align: center;
        color: #666;
        max-width: 500px;
        margin: 10px auto 30px;
        font-size: 14px;
      }

      #overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
      }

      #modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        width: 300px;
        transform: translate(-50%, -50%);
        background: #fff;
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        z-index: 1000;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        animation: slideDown 0.3s ease-in-out;
      }

      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      .modal-header {
        margin-bottom: 20px;
      }

      .modal-title {
        font-size: 20px;
        font-weight: bold;
        color: #333;
      }

      .modal-subtitle {
        font-size: 14px;
        color: #777;
        margin-top: 5px;
      }

      .call-buttons {
        display: flex;
        justify-content: space-around;
        margin-top: 20px;
      }

      .circle-btn {
        width: 60px;
        height: 60px;
        border: none;
        border-radius: 50%;
        font-size: 26px;
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease;
      }

      .circle-btn:hover {
        transform: scale(1.1);
      }

      .accept {
        background-color: #28a745;
      }

      .reject {
        background-color: #dc3545;
      }

      #call-timer {
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        color: #dc3545;
        display: none;
        margin: 20px 0;
      }

      #call-duration-result {
        text-align: center;
        font-size: 18px;
        color: #dc3545;
        margin-top: 10px;
      }

      .ringing {
        animation: pulse 1s infinite ease-in-out;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.3);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
        }
      }

      .debug-info {
        position: fixed;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        color: #00ff00;
        padding: 15px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        border-radius: 8px;
        max-width: 400px;
        line-height: 1.4;
      }

      .status-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-waiting {
        background-color: #ffc107;
      }
      .status-connecting {
        background-color: #17a2b8;
      }
      .status-connected {
        background-color: #28a745;
      }
      .status-error {
        background-color: #dc3545;
      }

      #terminate-btn {
        display: none;
        margin: 20px auto;
        background-color: #dc3545;
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
      }

      #terminate-btn:hover {
        background-color: #c82333;
      }
    </style>
  </head>
  <body>
    <h1>WhatsApp WebRTC Bridge</h1>
    <p class="description">
      This web app receives incoming WhatsApp API calls. When a call arrives,
      accept it to start the WebRTC bridge.
    </p>

    <h2
      id="call-status"
      style="text-align: center; color: #333; font-weight: normal"
    ></h2>
    <h3
      id="active-caller-name"
      style="text-align: center; color: #555; display: none"
    ></h3>

    <div id="call-timer">‚è±Ô∏è <span id="timer">00:00</span></div>

    <div id="call-duration-result"></div>

    <button id="terminate-btn" onclick="terminateCall()">üîö End Call</button>

    <!-- Call Modal -->
    <div id="overlay"></div>
    <div id="modal" class="ringing">
      <div class="modal-header">
        <div class="modal-title" id="caller-name">
          üì≤ Incoming WhatsApp Call
        </div>
        <div class="modal-subtitle" id="caller-number"></div>
        <div class="modal-subtitle">Answer or decline the call</div>
      </div>
      <div class="call-buttons">
        <button
          class="circle-btn accept"
          onclick="answerCall()"
          title="Accept Call"
        >
          üìû
        </button>
        <button
          class="circle-btn reject"
          onclick="rejectCall()"
          title="Reject Call"
        >
          üì¥
        </button>
      </div>
    </div>

    <!-- Debug Panel -->
    <div id="debug" class="debug-info">
      <div>üîç Debug Info</div>
      <div id="debug-content">Initializing...</div>
    </div>

    <script>
      const socket = io();

      // State variables
      let pc = null;
      let localStream = null;
      let callStartTime = null;
      let timerInterval = null;
      let currentCall = null;

      // UI Elements
      const callStatusEl = document.getElementById("call-status");
      const debugEl = document.getElementById("debug-content");
      const timerEl = document.getElementById("call-timer");
      const terminateBtn = document.getElementById("terminate-btn");

      function log(message, type = "info") {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`[${timestamp}] ${message}`);

        const emoji =
          type === "error"
            ? "‚ùå"
            : type === "success"
            ? "‚úÖ"
            : type === "warning"
            ? "‚ö†Ô∏è"
            : "‚ÑπÔ∏è";
        debugEl.innerHTML += `<div>${emoji} ${timestamp} - ${message}</div>`;
        debugEl.scrollTop = debugEl.scrollHeight;
      }

      function updateStatus(message, statusClass = "waiting") {
        callStatusEl.innerHTML = `<span class="status-indicator status-${statusClass}"></span>${message}`;
        log(`Status: ${message}`);
      }

      function startTimer() {
        callStartTime = Date.now();
        timerEl.style.display = "block";

        timerInterval = setInterval(() => {
          const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          document.getElementById("timer").textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }, 1000);

        log("Call timer started", "success");
      }

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }

        if (callStartTime) {
          const duration = Math.floor((Date.now() - callStartTime) / 1000);
          const minutes = Math.floor(duration / 60);
          const seconds = duration % 60;
          const durationStr = `${minutes.toString().padStart(2, "0")}:${seconds
            .toString()
            .padStart(2, "0")}`;

          document.getElementById(
            "call-duration-result"
          ).textContent = `üì¥ Call ended. Duration: ${durationStr}`;

          log(`Call ended. Duration: ${durationStr}`, "info");
        }

        timerEl.style.display = "none";
      }

      function resetUI() {
        callStatusEl.textContent = "";
        document.getElementById("active-caller-name").style.display = "none";
        document.getElementById("modal").style.display = "none";
        document.getElementById("overlay").style.display = "none";
        terminateBtn.style.display = "none";
        stopTimer();
      }

      async function checkMicrophone() {
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const hasMic = devices.some((device) => device.kind === "audioinput");
          if (!hasMic) {
            log("No microphone detected", "error");
            alert("No microphone detected. Please connect a microphone.");
            return false;
          }
          return true;
        } catch (error) {
          log(`Error checking devices: ${error.message}`, "error");
          return false;
        }
      }

      // Socket event handlers
      socket.on("call-is-coming", ({ callId, callerName, callerNumber }) => {
        log(`Incoming call: ${callerName} (${callerNumber})`, "info");
        currentCall = { callId, callerName, callerNumber };

        document.getElementById("caller-name").textContent = `üì≤ ${callerName}`;
        document.getElementById("caller-number").textContent = callerNumber;

        updateStatus("üì≤ Incoming call...", "warning");
        document.getElementById("modal").style.display = "block";
        document.getElementById("overlay").style.display = "block";
      });

      socket.on("start-browser-timer", () => {
        log("Timer start signal received", "success");
        startTimer();
        updateStatus("üî¥ Call in progress", "connected");
      });

      socket.on("call-ended", () => {
        log("Call ended by server", "info");
        cleanup();
        resetUI();
        updateStatus("", "waiting");
      });

      socket.on("browser-answer", async (sdp) => {
        log("Received answer SDP from server", "success");
        if (pc && pc.signalingState !== "closed") {
          try {
            await pc.setRemoteDescription(
              new RTCSessionDescription({ type: "answer", sdp })
            );
            log("Remote description set successfully", "success");
          } catch (error) {
            log(`Error setting remote description: ${error.message}`, "error");
          }
        }
      });

      socket.on("browser-candidate", async (candidate) => {
        if (pc && pc.signalingState !== "closed") {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            log("ICE candidate added", "success");
          } catch (error) {
            log(`ICE candidate error: ${error.message}`, "error");
          }
        }
      });

      // Call control functions
      async function answerCall() {
        if (!currentCall) return;

        log("User accepted the call", "success");
        document.getElementById("modal").style.display = "none";
        document.getElementById("overlay").style.display = "none";

        updateStatus("üîÑ Setting up call...", "connecting");
        document.getElementById(
          "active-caller-name"
        ).textContent = `With ${currentCall.callerName}`;
        document.getElementById("active-caller-name").style.display = "block";
        terminateBtn.style.display = "block";
        document.getElementById("call-duration-result").textContent = "";

        // Notify server
        socket.emit("accept-call", currentCall.callId);

        // Setup WebRTC
        await setupWebRTC();
      }

      function rejectCall() {
        if (!currentCall) return;

        log("User rejected the call", "info");
        socket.emit("reject-call", currentCall.callId);
        resetUI();
        updateStatus("", "waiting");
        currentCall = null;
      }

      function terminateCall() {
        if (!currentCall) return;

        log("User terminated the call", "info");
        socket.emit("terminate-call", currentCall.callId);
        cleanup();
        resetUI();
        updateStatus("", "waiting");
      }

      async function setupWebRTC() {
        try {
          if (!(await checkMicrophone())) {
            updateStatus("‚ùå No microphone available", "error");
            return;
          }

          log("Setting up WebRTC connection", "info");

          pc = new RTCPeerConnection({
            iceServers: [{ urls: "stun:stun.relay.metered.ca:80" }],
          });

          // Connection state monitoring
          pc.onconnectionstatechange = () => {
            log(`PC connection state: ${pc.connectionState}`, "info");
            if (pc.connectionState === "connected") {
              updateStatus("üî¥ Connected", "connected");
            } else if (pc.connectionState === "failed") {
              log("WebRTC connection failed", "error");
              updateStatus("‚ùå Connection failed", "error");
            }
          };

          pc.oniceconnectionstatechange = () => {
            log(`ICE state: ${pc.iceConnectionState}`, "info");
          };

          // Handle incoming audio
          pc.ontrack = (event) => {
            log("Received remote audio track", "success");
            const audio = new Audio();
            audio.srcObject = event.streams[0];
            audio.autoplay = true;
            audio.volume = 1.0;

            audio.onplay = () => log("Audio playback started", "success");
            audio.onerror = (e) => log(`Audio error: ${e}`, "error");

            document.body.appendChild(audio);
          };

          // Send ICE candidates
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              socket.emit("browser-candidate", event.candidate);
              log("ICE candidate sent to server", "info");
            }
          };

          // Get microphone
          log("Requesting microphone access", "info");
          try {
            localStream = await navigator.mediaDevices.getUserMedia({
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
            });
            log("Microphone access granted", "success");
          } catch (error) {
            if (
              error.name === "NotFoundError" ||
              error.name === "DevicesNotFoundError"
            ) {
              alert(
                "No microphone found. Please connect a microphone and try again."
              );
              log("No microphone found", "error");
            } else if (error.name === "NotAllowedError") {
              alert(
                "Microphone access denied. Please allow microphone access in your browser settings and refresh."
              );
              log("Microphone access denied", "error");
            } else {
              alert("Failed to access microphone: " + error.message);
              log(`Microphone access error: ${error.message}`, "error");
            }
            updateStatus("‚ùå Setup failed", "error");
            return; // Exit the function to prevent further errors
          }

          // Add local tracks
          localStream.getTracks().forEach((track) => {
            pc.addTrack(track, localStream);
            log(`Added ${track.kind} track to PC`, "info");
          });

          // Create offer
          log("Creating WebRTC offer", "info");
          const offer = await pc.createOffer({ offerToReceiveAudio: true });
          await pc.setLocalDescription(offer);

          socket.emit("browser-offer", offer.sdp);
          log("Offer sent to server", "success");
        } catch (error) {
          log(`WebRTC setup error: ${error.message}`, "error");
          alert("WebRTC setup failed: " + error.message);
          updateStatus("‚ùå Setup failed", "error");
        }
      }

      function cleanup() {
        if (pc) {
          pc.close();
          pc = null;
          log("WebRTC connection closed", "info");
        }

        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
          log("Local stream stopped", "info");
        }

        // Remove audio elements
        document.querySelectorAll("audio").forEach((audio) => audio.remove());

        currentCall = null;
      }

      // Initialize
      updateStatus("Waiting for calls...", "waiting");
      log("WhatsApp WebRTC Bridge initialized", "success");
    </script>
  </body>
</html>
